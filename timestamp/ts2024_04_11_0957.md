---
tags:
  - timestamp
date: 2024-04-11
time: 09:57
status: draft
---

# [title:: Vue Watcher]

`watch` 函数是 `'vue'` 的命名导出，引入：

```js
import { watch } from 'vue'
```

第一个参数可以是响应式对象、计算属性、getter 函数等等。对于 getter 函数：

```js
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x and y is ${sum}`)
  }
)
```

不能直接监听响应式对象的属性值，需要使用一个返回该属性的 getter 函数：

```js
const obj = reactive({ count: 0 })

watch(obj.count, (count) => {  // 错误
  console.log(`count is: ${count}`)
})

watch(  // 正确
  () => obj.count,
  (count) => {
    console.log(`count is: ${count}`)
  }
)
```

直接监听响应式对象将隐式创建一个 deep watcher；而一个返回响应式对象的 getter 函数需要显式加上 `deep` 选项以转换为 deep watcher。

如果 watch 的 callback 中使用了与 source 相同的响应式状态，如：

```js
const todoId = ref(1)

watch(
  todoId,
  async () => {
    const response = await fetch(
      `https://example.com/${todoId}`
    )
    console.log(response.json())
  },
  { immediate: true }
}
```

即 `todoId` 状态同时出现在 source 和 callback 中。可以使用 `watchEffect` 简化：

```js
const todoId = ref(1)

watchEffect(async () => {
  const response = await fetch(
    `https://example.com/${todoId}`
  )
  console.log(response.json())
})
```

`watchEffect` 函数会自动跟踪 callback 的响应式依赖。且在 `watchEffect` 中，callback 会立即执行，即自带 `immediate: true` 选项。
